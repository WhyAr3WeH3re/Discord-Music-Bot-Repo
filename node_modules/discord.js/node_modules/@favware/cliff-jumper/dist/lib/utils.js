import { packageCwd } from '#lib/constants';
import { Result } from '@sapphire/result';
import { isFunction, isNullishOrEmpty, isThenable } from '@sapphire/utilities';
import { cyan, green, red } from 'colorette';
import { load } from 'js-yaml';
import { execSync } from 'node:child_process';
import { readFile } from 'node:fs/promises';
import { join } from 'node:path';
export async function usesModernYarn() {
    const packageJsonPath = join(packageCwd, 'package.json');
    const packageJsonContent = await readJson(packageJsonPath);
    if (!packageJsonContent.packageManager)
        return false;
    return packageJsonContent.packageManager.startsWith('yarn@3');
}
/**
 * Parsed a YAML file into an `Object` of type `T`
 * @param pathLike The {@link PathLike} to read with {@link readFile}
 */
export async function readYaml(pathLike) {
    return load(await readFile(pathLike, { encoding: 'utf-8' }));
}
/**
 * Parses a JSON file into an `Object` of type `T`
 * @param pathLike The {@link PathLike} to read with {@link readFile}
 */
export async function readJson(pathLike) {
    return JSON.parse(await readFile(pathLike, { encoding: 'utf-8' }));
}
export function getGitRootDirection() {
    const repositoryRoot = execSync('git rev-parse --show-prefix', { encoding: 'utf-8' });
    return repositoryRoot
        .split('/')
        .map((i) => i.trim())
        .filter(Boolean)
        .map(() => '..')
        .join('/');
}
export function getFullPackageName(options) {
    return options.org ? `@${options.org}/${options.name}` : options.name;
}
export async function doActionAndLog(preActionLog, action) {
    process.stdout.write(cyan(`${preActionLog}... `));
    const result = await Result.fromAsync(async () => {
        const executedFunctionResult = isFunction(action) ? action() : action;
        const returnValue = isThenable(executedFunctionResult) ? (await executedFunctionResult) : executedFunctionResult;
        console.log(green('✅ Done'));
        return returnValue;
    });
    if (result.isErr()) {
        console.log(red('❌ Error'));
        console.error(result.unwrapErr().message);
        process.exit(1);
    }
    return result.unwrap();
}
export function resolveTagTemplate(options, newVersion) {
    if (isNullishOrEmpty(options.tagTemplate)) {
        if (isNullishOrEmpty(options.org)) {
            options.tagTemplate = 'v{{new-version}}';
        }
        else {
            options.tagTemplate = `{{full-name}}@{{new-version}}`;
        }
    }
    options.tagTemplate = options.tagTemplate
        .replaceAll('{{new-version}}', newVersion)
        .replaceAll('{{org}}', options.org)
        .replaceAll('{{name}}', options.name)
        .replaceAll('{{full-name}}', getFullPackageName(options));
}
/** Resolves the release-as prefix */
export const getReleaseType = (options, changelogResolvedReleaseType) => ((Boolean(options.preid) ? 'pre' : '') + changelogResolvedReleaseType);
//# sourceMappingURL=utils.js.map